1
00:00:00,200 --> 00:00:02,850
Next let's try inserting an element.

2
00:00:02,850 --> 00:00:08,290
We could take the approach we used with
BST's, start at the root then move

3
00:00:08,290 --> 00:00:12,740
down the tree one level at a time and do
comparisons until we find an open spot.

4
00:00:12,740 --> 00:00:16,880
However, if our element is bigger
than most of the parent nodes or

5
00:00:16,880 --> 00:00:19,990
even the root we'll need to
shuffle the tree around a lot.

6
00:00:19,990 --> 00:00:23,400
As such, we take a different
approach to inserting here.

7
00:00:23,400 --> 00:00:26,900
We can stick the new element in
the next open spot in the tree.

8
00:00:26,900 --> 00:00:28,660
Then we heapify.

9
00:00:28,660 --> 00:00:32,299
Heapify is the operation in
which we reorder the tree

10
00:00:32,299 --> 00:00:34,230
based on the heap property.

11
00:00:34,230 --> 00:00:38,990
Since we care that our parent
element is bigger than its child,

12
00:00:38,100 --> 00:00:41,520
we just need to keep comparing our
new element with its parent and

13
00:00:41,520 --> 00:00:43,260
swapping them when the child is bigger.

14
00:00:44,840 --> 00:00:48,530
We can take a similar approach
to an extract operation

15
00:00:48,530 --> 00:00:50,980
where the root is removed from the tree.

16
00:00:50,980 --> 00:00:54,190
We stick the rightmost
leaf in the root spot

17
00:00:54,190 --> 00:00:58,739
then just compare it to its children and
swap where necessary.

18
00:00:58,740 --> 00:01:01,300
The runtime of insert and delete,

19
00:01:01,300 --> 00:01:07,630
a more general case of extract ends
up being O of log in the worst case.

20
00:01:07,630 --> 00:01:12,600
Ultimately the worst case would involve
moving an element all the way up or down

21
00:01:12,600 --> 00:01:16,839
the tree and would roughly be as many
operations as the height of the tree.
