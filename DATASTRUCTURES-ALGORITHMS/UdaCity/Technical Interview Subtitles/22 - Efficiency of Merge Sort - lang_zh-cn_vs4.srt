1
00:00:00,590 --> 00:00:03,880
那么整体对比次数是多少次？

2
00:00:03,880 --> 00:00:06,680
我们来找找规律

3
00:00:06,680 --> 00:00:08,500
看起来对于每个步骤

4
00:00:08,500 --> 00:00:12,510
对比次数都比要构建的数组大小小 1

5
00:00:12,510 --> 00:00:17,300
所以当我们要构建大小为 7 的数组时 我们对比了 6 次

6
00:00:17,300 --> 00:00:21,586
当我们要构建大小为 3 的数组时 我们对比了 2 次

7
00:00:21,586 --> 00:00:25,299
大小为 2 时 对比了 1 次 大小为 4 时 对比了 3 次

8
00:00:26,430 --> 00:00:27,580
为了简单起见

9
00:00:27,580 --> 00:00:31,259
我将每个数组的长度称作 m

10
00:00:32,409 --> 00:00:36,510
如果 m 是要构建的数组的大小

11
00:00:36,510 --> 00:00:40,440
对比次数就始终比 m 小 1

12
00:00:40,440 --> 00:00:44,470
很难算出这里的精确对比次数

13
00:00:44,470 --> 00:00:49,120
但是我们可以依赖好用的近似值

14
00:00:49,120 --> 00:00:52,379
因为我们知道每次迭代都是

15
00:00:52,380 --> 00:00:56,730
不断循环访问同样的 7 个元素 我们知道数组的大小 m

16
00:00:56,730 --> 00:01:01,500
最终都会相加等于 7

17
00:01:01,500 --> 00:01:03,989
所以这里是大小为 7 的数组

18
00:01:03,990 --> 00:01:08,191
这里是大小为 4 的数组 这里是大小为 3 的数组 而 4+3=7

19
00:01:08,191 --> 00:01:12,370
这里是 1、2、2、2 相加等于 7

20
00:01:13,410 --> 00:01:14,780
因为我们采用的是分治法

21
00:01:14,780 --> 00:01:18,780
每步都拆分数组 可以近似地说

22
00:01:18,780 --> 00:01:21,400
we're going to do seven
每步的对比次数是 7 次

23
00:01:22,380 --> 00:01:24,240
7 是上限

24
00:01:24,240 --> 00:01:27,390
对比次数绝对不会超过 7 次

25
00:01:27,390 --> 00:01:29,260
但是很多步骤会接近于 7

26
00:01:30,740 --> 00:01:34,890
所以为了得出排序算法的运行时间

27
00:01:34,890 --> 00:01:40,370
通常可以将整个循环次数乘以每次循环的对比次数

28
00:01:40,370 --> 00:01:44,940
在冒泡排序中是 n 次对比和 n 个步骤

29
00:01:44,940 --> 00:01:48,750
我们刚证明了每步最多对比 n 次

30
00:01:49,940 --> 00:01:52,500
但是总共需要多少步呢？

31
00:01:53,180 --> 00:01:55,735
要对大小为 7 的数组排序

32
00:01:55,735 --> 00:02:00,600
我们需要执行 3 步 第一步 第二步 第三步

33
00:02:01,600 --> 00:02:04,475
同时 还要注意这里发生的子流程

34
00:02:05,485 --> 00:02:09,520
为了对这个大小为 2 的数组排序 我们只需要 1 步

35
00:02:11,140 --> 00:02:13,455
要对大小为 3 或 4 的数组排序

36
00:02:13,455 --> 00:02:17,550
我们需要 2 步

37
00:02:17,550 --> 00:02:20,295
我们可以用表格来记录这些结果

38
00:02:20,295 --> 00:02:25,350
当数组大小是 7 时 我们需要 3 个不同的步骤

39
00:02:25,350 --> 00:02:30,230
当数组大小是 3 或 4 时 我们需要 2 步

40
00:02:30,230 --> 00:02:33,852
当数组大小为 2 时 我们需要 1 步

41
00:02:33,853 --> 00:02:38,500
如果只有 1 个元素 我们不需要进行任何对比 所以没有步骤

42
00:02:39,342 --> 00:02:43,600
为了节省时间 我在这些方框中直接填上结果

43
00:02:43,600 --> 00:02:46,420
你可以假设我自己已经完成了这些计算

44
00:02:46,420 --> 00:02:48,609
建议你也私底下计算下

45
00:02:48,610 --> 00:02:52,100
你对这组数据可能有些熟悉

46
00:02:52,100 --> 00:02:56,300
记得在二分查找中 我们也得出了类似的表格

47
00:02:56,300 --> 00:03:00,700
循环次数是 2 的幂

48
00:03:00,700 --> 00:03:03,679
实际上这组数据非常相似

49
00:03:03,679 --> 00:03:05,912
这次我们是以 2 的幂加 1 来增加数据

50
00:03:05,912 --> 00:03:08,845
而不是 2 的幂

51
00:03:08,845 --> 00:03:11,137
[无声音]

52
00:03:11,137 --> 00:03:13,540
在二分查找视频中

53
00:03:13,540 --> 00:03:16,850
我证明了为何循环次数等于 log(n)

54
00:03:16,850 --> 00:03:18,810
如果你需要复习下 可以再返回观看该视频

55
00:03:20,550 --> 00:03:23,230
这次的情形有点不同 因为是以 2 的幂之后的数字增加的

56
00:03:23,230 --> 00:03:26,220
而不是 2 的幂

57
00:03:26,220 --> 00:03:29,765
但是 我们这里依赖的也是近似值

58
00:03:29,765 --> 00:03:33,665
我们并不关心哪里出现了变化

59
00:03:33,665 --> 00:03:36,655
只需要了解变化间隔就行了

60
00:03:38,195 --> 00:03:45,594
总结下 我们是进行 n 次对比和 log(n) 个步骤

61
00:03:45,594 --> 00:03:49,236
整个复杂度就是 nlog(n)

62
00:03:49,236 --> 00:03:52,570
这绝对比冒泡排序中的 n2 要理想

63
00:03:53,610 --> 00:03:58,640
在冒泡排序中 效率是 n x n 即 n2

64
00:04:00,105 --> 00:04:02,840
log(n) 通常比 n 要小

65
00:04:02,840 --> 00:04:05,650
但是绝对不会比 n 大

66
00:04:05,650 --> 00:04:08,450
所以可以说归并排序的效率比

67
00:04:08,450 --> 00:04:09,750
冒泡排序要高

68
00:04:11,800 --> 00:04:15,800
但是 归并排序的空间效率实际上比冒泡排序要低

69
00:04:16,260 --> 00:04:18,630
在冒泡排序中 我们是原地排序

70
00:04:18,630 --> 00:04:20,690
所以不需要额外的数组

71
00:04:21,860 --> 00:04:24,770
但是对于归并排序 我们频繁地将值复制到新的数组中

72
00:04:26,500 --> 00:04:32,420
可以说用到的辅助空间或额外空间是线性的

73
00:04:32,420 --> 00:04:36,909
这个复杂度是假设我们在使用数组后 直接抛弃它们了

74
00:04:36,909 --> 00:04:40,605
每一步 我们都将值复制到新的数组中

75
00:04:40,605 --> 00:04:42,926
所以在某个点我们需要新的数组

76
00:04:42,926 --> 00:04:46,195
但是也可以说每次操作完毕后 我们都会抛弃

77
00:04:46,196 --> 00:04:47,340
旧数组

78
00:04:47,340 --> 00:04:49,940
所以每次也不是用到很多的新数组

79
00:04:49,940 --> 00:04:54,210
每一步只需要两个不同的数组

80
00:04:54,210 --> 00:04:57,400
一个放我们的数字 一个将新值拷贝进来
