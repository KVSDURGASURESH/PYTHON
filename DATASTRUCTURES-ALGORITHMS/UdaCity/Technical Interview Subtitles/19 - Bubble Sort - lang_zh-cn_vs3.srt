1
00:00:00,660 --> 00:00:06,720
冒泡排序 也叫做沉底排序 如我之前所描述的 是一种低级排序法

2
00:00:06,720 --> 00:00:09,670
你需要将数组中的每个元素与其两侧的元素对比

3
00:00:09,670 --> 00:00:11,180
并在必要时交换顺序

4
00:00:12,370 --> 00:00:13,989
我用一个简短示例演示下

5
00:00:15,380 --> 00:00:18,250
我们从头开始 对比前两个元素

6
00:00:19,430 --> 00:00:22,540
如果第一个元素比第二个大 就交换它俩

7
00:00:24,100 --> 00:00:25,540
我们做出第一次交换

8
00:00:25,540 --> 00:00:29,800
然后继续对比下两个元素

9
00:00:29,800 --> 00:00:31,259
看起来这里也要交换

10
00:00:31,260 --> 00:00:34,697
接着继续对比下两个元素

11
00:00:34,697 --> 00:00:38,910
同样 第一个元素比第二个大

12
00:00:38,910 --> 00:00:40,900
需要交换下

13
00:00:40,900 --> 00:00:43,410
现在可以对比数组中的最后两个元素了

14
00:00:43,410 --> 00:00:46,959
第一个元素再次比第二个大

15
00:00:46,960 --> 00:00:47,770
我们还需要交换一次

16
00:00:48,860 --> 00:00:50,910
这轮排序就结束了

17
00:00:50,910 --> 00:00:53,400
现在我们已经浏览完数组

18
00:00:53,400 --> 00:00:56,199
我们应该计算所需的对比次数

19
00:00:56,200 --> 00:00:59,590
我们需要对比 4 次才能排完 5 个元素

20
00:01:00,160 --> 00:01:02,842
可以准确地说这个步骤的运行时间是 n-1

21
00:01:02,842 --> 00:01:06,660
因为数组大小是 5

22
00:01:06,660 --> 00:01:10,220
所以经过 n-1 次对比后 实际上有什么变化？

23
00:01:10,220 --> 00:01:14,179
数组还没有完成排序 但是看起来好些了

24
00:01:14,180 --> 00:01:18,540
最大的元素 8 已经移到该呆的位置 也就是数组的末尾处

25
00:01:18,540 --> 00:01:21,470
这就是为何这个方法叫做冒泡排序

26
00:01:21,470 --> 00:01:26,700
在每次循环时 最大的元素都会冒到最上面

27
00:01:26,700 --> 00:01:27,830
所以照着这个逻辑

28
00:01:27,830 --> 00:01:32,360
下次循环时 7 将冒到 8 的下面

29
00:01:32,360 --> 00:01:34,800
我们来重复下这个过程

30
00:01:34,800 --> 00:01:37,940
我们还是从底部开始 逐渐操作到顶部

31
00:01:37,940 --> 00:01:39,789
Looks like we need to
看起来第一步就需要交换

32
00:01:41,330 --> 00:01:42,920
现在转到第二步

33
00:01:42,920 --> 00:01:46,390
看来首次不用交换这两个元素了

34
00:01:46,390 --> 00:01:49,480
第一个元素实际上比第二个元素小

35
00:01:49,480 --> 00:01:51,350
所以我们不用执行任何操作 太棒了

36
00:01:51,350 --> 00:01:53,740
但是我们的确需要交换 7 和 0

37
00:01:53,740 --> 00:01:56,630
最后两个元素已经排好序 所有不需要任何操作

38
00:01:56,630 --> 00:02:00,570
这次我们需要 4 步 依然满足 n-1

39
00:02:00,570 --> 00:02:03,479
我们还需要进行两轮排序

40
00:02:03,480 --> 00:02:05,310
但是我就不详细演示了

41
00:02:05,310 --> 00:02:08,729
我直接展示下下个对比循环的结果如何

42
00:02:08,729 --> 00:02:11,590
我又循环了一次 但是没多大变化

43
00:02:11,590 --> 00:02:15,000
我只需要交换下 3 和 0 结果是这样

44
00:02:15,000 --> 00:02:19,410
剩下的最大元素 3 冒到了该呆的位置

45
00:02:19,410 --> 00:02:21,170
我们依然需要继续操作

46
00:02:21,170 --> 00:02:25,220
同样需要 4 步 也就是 n-1 步

47
00:02:25,220 --> 00:02:26,940
只需要循环一次就行了

48
00:02:26,940 --> 00:02:28,720
我演示下结果是怎样的

49
00:02:28,720 --> 00:02:31,820
这次只需要交换 0 和 1 就完成整个排序了
