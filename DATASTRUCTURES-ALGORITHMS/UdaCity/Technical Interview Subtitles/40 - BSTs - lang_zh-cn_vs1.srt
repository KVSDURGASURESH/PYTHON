1
00:00:00,800 --> 00:00:04,734
二叉树存在一个具体的类型 叫做二叉查找树

2
00:00:04,734 --> 00:00:10,690
二叉查找树简称 BST 肯定是二叉树

3
00:00:10,690 --> 00:00:14,219
即每个父节点最多有两个子节点

4
00:00:14,220 --> 00:00:20,700
但是就像数组是列表的一种类型 BST 也是二叉树的一种类型

5
00:00:20,700 --> 00:00:21,490
每个节点对应的值

6
00:00:21,490 --> 00:00:25,430
会按特定的规则排列

7
00:00:25,430 --> 00:00:30,000
BST 是排好序的 每个节点左侧的节点对应的值都比它小

8
00:00:30,100 --> 00:00:34,739
右侧的节点对应的值都比它大

9
00:00:34,739 --> 00:00:39,714
因为 BST 具有这一特殊结构 所以我们可以快速对其进行查找

10
00:00:39,715 --> 00:00:41,580
插入和删除操作

11
00:00:41,580 --> 00:00:43,259
假设我们要找到 7

12
00:00:43,259 --> 00:00:45,340
我们从根部开始

13
00:00:45,340 --> 00:00:49,200
因为 7 比 5 大 所以下一步往右侧移动

14
00:00:49,200 --> 00:00:52,730
因为下一个元素是 8 所以再下一步是往左侧查看

15
00:00:52,730 --> 00:00:55,290
只需几步 就找到 7 了

16
00:00:55,290 --> 00:00:58,900
你可能注意到了 我们不需要查找每个元素

17
00:00:58,900 --> 00:01:01,170
就能知道目标元素位于何处

18
00:01:01,170 --> 00:01:04,680
我们只需要查看每一层级的一个值

19
00:01:04,680 --> 00:01:08,130
然后将其与目标元素进行对比就行了

20
00:01:08,130 --> 00:01:12,690
也就意味着 BST 查找操作的运行时间是树的高度

21
00:01:12,690 --> 00:01:16,220
我们在学习插入时已经证明是 log(n)

22
00:01:16,220 --> 00:01:20,300
二叉树插入操作基本上是相同的流程

23
00:01:20,300 --> 00:01:23,960
从顶部开始 每一步通过对比要插入的元素

24
00:01:23,960 --> 00:01:27,169
快速决定要往何处移动

25
00:01:27,170 --> 00:01:29,430
最终找到空缺位置

26
00:01:30,530 --> 00:01:34,100
只要每步都正确地对比了目标元素

27
00:01:34,100 --> 00:01:38,310
就可以将新元素放在相关空缺位置 并且不违反 BST 的核心特性

28
00:01:39,650 --> 00:01:42,180
删除则比较复杂

29
00:01:43,280 --> 00:01:46,820
但是和普通二叉树的复杂程度一样

30
00:01:46,820 --> 00:01:50,710
所以不同情形下的解决方案依然适用
