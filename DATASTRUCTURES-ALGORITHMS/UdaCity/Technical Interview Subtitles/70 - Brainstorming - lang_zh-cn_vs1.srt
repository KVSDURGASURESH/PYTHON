1
00:00:00,190 --> 00:00:00,960
好的

2
00:00:00,960 --> 00:00:04,750
现在我看看这些可能的输入情况

3
00:00:04,750 --> 00:00:08,200
如果要考虑 none 和空的矩阵

4
00:00:08,200 --> 00:00:10,490
我们则需要返回 0

5
00:00:10,500 --> 00:00:14,280
因为在这种情况下 肯定没有孤岛

6
00:00:14,280 --> 00:00:16,990
但是这也是一种输入情况

7
00:00:16,990 --> 00:00:20,639
我们可以从第一个元素开始

8
00:00:20,640 --> 00:00:21,670
是个 1

9
00:00:21,670 --> 00:00:24,120
我可能需要某种孤岛计数器变量

10
00:00:24,120 --> 00:00:26,960
我将初始化它并加 1

11
00:00:26,960 --> 00:00:28,590
然后转到 0

12
00:00:28,590 --> 00:00:30,875
它不是任何孤岛

13
00:00:30,875 --> 00:00:32,270
所以不需要进行任何操作

14
00:00:32,270 --> 00:00:33,990
然后转到下个元素

15
00:00:36,180 --> 00:00:39,600
它实际上是同一个孤岛的一部分

16
00:00:39,600 --> 00:00:44,180
所以我需要跟踪哪些 1 是同一孤岛的一部分

17
00:00:47,200 --> 00:00:51,100
也许我可以查看顶部和底部的元素

18
00:00:51,100 --> 00:00:55,300
然后看看它们是不是同一孤岛的一部分

19
00:00:55,300 --> 00:00:57,446
然后继续跟踪

20
00:00:57,446 --> 00:01:02,400
是的 那是一种方法 但是如果你查看这个首个元素

21
00:01:02,400 --> 00:01:06,350
下方有一个 1 但是上方没有任何元素

22
00:01:06,350 --> 00:01:08,000
在这种情况下 你该怎么办？

23
00:01:08,000 --> 00:01:11,800
因为上方没有 1

24
00:01:11,800 --> 00:01:12,929
所以可能会遇到某种运行时错误

25
00:01:12,930 --> 00:01:15,670
首先我会确保检查下那里有个元素

26
00:01:15,670 --> 00:01:19,737
然后再检查它是 1 还是 0

27
00:01:22,570 --> 00:01:24,625
所以我也需要跟踪这一点

28
00:01:24,625 --> 00:01:27,670
也许这是某种数据结构

29
00:01:27,670 --> 00:01:30,110
恩 这个方法或问题

30
00:01:30,110 --> 00:01:32,940
或任何过程有没有让你想到任何内容？

31
00:01:32,940 --> 00:01:36,900
恩 因为这个矩阵可以表示为图表

32
00:01:36,900 --> 00:01:38,900
可能是个广度优先搜索问题

33
00:01:38,900 --> 00:01:41,240
当我找到第一个元素时

34
00:01:41,240 --> 00:01:45,160
可以看看它四周的元素 并将这些元素添加到队列中

35
00:01:45,160 --> 00:01:49,390
看看这些是不是 1 如果是 1

36
00:01:49,400 --> 00:01:51,700
我可以将它们设为另一个数字 标记为我已经查看过了

37
00:01:51,700 --> 00:01:53,169
然后可以继续

38
00:01:53,170 --> 00:01:54,250
恩 听起来很不错

39
00:01:56,140 --> 00:01:59,370
当讨论他的解决方案时 似乎他的测试条件

40
00:01:59,370 --> 00:02:00,370
很有用

41
00:02:00,370 --> 00:02:01,200
是的

42
00:02:02,650 --> 00:02:07,360
他能够通过测试条件逐步找到解决方案

43
00:02:07,360 --> 00:02:10,340
我还注意到他能够与面试官

44
00:02:10,340 --> 00:02:11,670
很好地沟通

45
00:02:11,670 --> 00:02:14,859
他利用面试官的提示逐步找到正确的解决方案

46
00:02:15,950 --> 00:02:19,369
很多面试者的误解是

47
00:02:19,370 --> 00:02:21,900
面试官不会站在你这一边

48
00:02:21,900 --> 00:02:24,390
但实际上 面试官是在帮助你

49
00:02:24,390 --> 00:02:28,799
能够接受他们的反馈表明你具有良好的团队技能

50
00:02:28,800 --> 00:02:31,420
且不说沟通技能能帮助你解决问题

51
00:02:31,420 --> 00:02:34,109
有时候在面试过程中 面试者太紧张了

52
00:02:34,110 --> 00:02:37,720
完全忽略了面试官的建议

53
00:02:37,720 --> 00:02:40,370
这对面试者来说 是个非常大的障碍

54
00:02:40,370 --> 00:02:44,170
当面试者看了测试条件和边界条件后

55
00:02:44,170 --> 00:02:45,140
依然找不到答案 该怎么办？

56
00:02:45,140 --> 00:02:49,490
面试者提到的一点是这个问题让他想起了

57
00:02:49,500 --> 00:02:51,510
广度优先搜索算法

58
00:02:51,510 --> 00:02:54,739
通常 如果面试者在问题的某个环节卡住了

59
00:02:54,740 --> 00:02:58,210
他们可以思考下算法和数据结构

60
00:02:58,210 --> 00:03:02,240
面试者可能会注意到图表可以表示为矩阵

61
00:03:02,240 --> 00:03:04,690
广度优先搜索可能比较适合这个问题
