1
00:00:00,520 --> 00:00:02,940
现在开始讲解排序算法

2
00:00:02,940 --> 00:00:06,200
对于查找算法 我们面对的是某种列表

3
00:00:06,200 --> 00:00:07,600
只需查看每个元素就行了

4
00:00:08,850 --> 00:00:12,590
但是 对于排序算法 你需要更改数组中元素的

5
00:00:12,590 --> 00:00:13,120
顺序

6
00:00:14,240 --> 00:00:17,570
假设你想要按高度对这些小动物排序

7
00:00:17,570 --> 00:00:20,100
首先你需要做出一些决定

8
00:00:20,100 --> 00:00:24,600
我是把最矮的元素放在这端 还是这端？

9
00:00:24,600 --> 00:00:26,900
我该用哪个算法来排序？

10
00:00:27,360 --> 00:00:30,450
你可以将每个元素与其他所有元素对比

11
00:00:30,450 --> 00:00:32,820
然后对所有元素排好序

12
00:00:32,820 --> 00:00:36,200
这种方法属于低级方法 因为你没有实际用到技巧

13
00:00:36,200 --> 00:00:37,500
或高效的算法

14
00:00:38,650 --> 00:00:42,570
当你遇到新的问题时 脑中首先想到的就是

15
00:00:42,570 --> 00:00:43,160
低级方法

16
00:00:44,420 --> 00:00:48,520
你会觉得 我知道我可以这么操作 一切都会正常

17
00:00:48,520 --> 00:00:51,710
但是很可能还有更加便捷的方法

18
00:00:52,750 --> 00:00:55,350
排序是个很奇怪的内容

19
00:00:55,350 --> 00:00:58,500
你很少会遇到无法使用我们这节课

20
00:00:58,500 --> 00:01:00,360
讲到的经典排序算法解决的问题

21
00:01:01,790 --> 00:01:05,310
对于面试来说 一定要理解算法的原理

22
00:01:05,310 --> 00:01:08,420
并记住运行次数

23
00:01:08,420 --> 00:01:11,200
这样可以很快地回答复杂度问题

24
00:01:12,400 --> 00:01:15,200
最后 一定要确保考虑了你的排序算法

25
00:01:15,200 --> 00:01:17,400
是不是原地算法

26
00:01:18,200 --> 00:01:21,130
原地排序算法就是在原来的数据结构中重新排列元素

27
00:01:21,130 --> 00:01:24,640
不需要将所有元素都复制到

28
00:01:24,640 --> 00:01:26,430
新的数据结构中

29
00:01:27,430 --> 00:01:29,990
这种算法的空间复杂度很低

30
00:01:29,990 --> 00:01:31,979
因为你不需要重新创建数据结构

31
00:01:33,390 --> 00:01:37,190
通常 你需要作出典型的权衡 是使用更少的空间

32
00:01:37,190 --> 00:01:37,920
还是更少的时间

33
00:01:39,600 --> 00:01:42,900
如果数组只有 10 个数字 实际上不会产生多大影响

34
00:01:42,900 --> 00:01:46,400
但是如果有数百万或数十亿的数据 那么差别就大了

35
00:01:47,800 --> 00:01:49,660
在面试中提到这点 肯定不会有坏处

36
00:01:49,660 --> 00:01:53,840
你可以选择更少的时间或更少的空间 但是一定要解释原因

37
00:01:53,840 --> 00:01:56,880
为你的选择提供更多理由 就会显得你更加专业
