1
00:00:00,200 --> 00:00:02,850
现在我们尝试插入元素

2
00:00:02,850 --> 00:00:08,290
我们可以采用 BST 用到的方法 从根部开始往下移动

3
00:00:08,290 --> 00:00:12,740
每次移动一个层级并进行对比 直到找到空位

4
00:00:12,740 --> 00:00:16,880
但是 如果目标元素比多数父节点都大

5
00:00:16,880 --> 00:00:19,990
甚至比根节点还大 我们就需要移动树中的大量节点

6
00:00:19,990 --> 00:00:23,400
因此 我们采用另一种插入方法

7
00:00:23,400 --> 00:00:26,900
我们可以将新元素放在树中的下一个空位处

8
00:00:26,900 --> 00:00:28,660
然后堆化

9
00:00:28,660 --> 00:00:32,299
堆化是指根据堆的属性重新对树

10
00:00:32,299 --> 00:00:34,230
进行排序

11
00:00:34,230 --> 00:00:38,990
因为父元素要比子节点大

12
00:00:38,100 --> 00:00:41,520
我们只需要不断对比目标元素与其父节点

13
00:00:41,520 --> 00:00:43,260
当子节点更大时 就交换它们

14
00:00:44,840 --> 00:00:48,530
提取操作也可以采取类似的方法

15
00:00:48,530 --> 00:00:50,980
我们删掉根节点

16
00:00:50,980 --> 00:00:54,190
我们在根位置粘上最右侧的叶子

17
00:00:54,190 --> 00:00:58,739
然后将其与子节点对比 并在必要时交换它们

18
00:00:58,740 --> 00:01:01,300
最坏情况下

19
00:01:01,300 --> 00:01:07,630
插入和删除（提取的更常规情况）操作的运行时间是 O(log(n))

20
00:01:07,630 --> 00:01:12,600
最坏情况下 最终可能是需要将元素一直往上或往下移动

21
00:01:12,600 --> 00:01:16,839
操作次数大概等于树的高度
