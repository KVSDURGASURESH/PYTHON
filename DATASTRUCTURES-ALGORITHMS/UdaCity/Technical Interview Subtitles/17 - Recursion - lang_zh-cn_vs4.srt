1
00:00:00,430 --> 00:00:04,710
递归可能是计算机科学中最令人费解的内容

2
00:00:04,710 --> 00:00:08,230
如果遇到任何不懂的地方 请不断阅读示例

3
00:00:08,230 --> 00:00:10,930
并尝试找到更多的示例 直到弄明白为止

4
00:00:12,540 --> 00:00:15,629
背后的概念就是创建一个调用自己的函数

5
00:00:17,180 --> 00:00:20,900
这是一个非常基础的伪代码示例

6
00:00:21,740 --> 00:00:24,380
这段代码不能实现任何有用的结果

7
00:00:24,380 --> 00:00:26,790
但是展示出了递归函数的主要部分

8
00:00:28,320 --> 00:00:31,700
首先 递归函数在一定情况下需要调用自己

9
00:00:33,140 --> 00:00:36,600
其次 递归函数需要有个基线条件

10
00:00:36,600 --> 00:00:40,100
在某些方面 你可以将递归函数想象成

11
00:00:40,100 --> 00:00:40,880
while 循环

12
00:00:42,800 --> 00:00:44,530
你会不断循环执行某些代码

13
00:00:44,530 --> 00:00:46,630
直到满足了退出条件

14
00:00:48,460 --> 00:00:51,960
在递归函数中 基线条件就相当于退出条件

15
00:00:51,960 --> 00:00:53,410
它可以告诉你何时停止运行代码

16
00:00:54,800 --> 00:00:56,879
如果没有一个这样的完美基线条件

17
00:00:56,880 --> 00:01:00,430
你可能会陷入无限递归中

18
00:01:00,430 --> 00:01:04,700
意味着你的代码不断调用自己

19
00:01:04,700 --> 00:01:07,180
执行一次又一次

20
00:01:07,180 --> 00:01:11,160
但是你从未告诉它什么时候停止 它会无限持续下去

21
00:01:12,720 --> 00:01:15,250
递归函数还要做的第三件事是

22
00:01:15,250 --> 00:01:17,619
在某一时刻更改输入参数

23
00:01:18,740 --> 00:01:20,839
如果你不更改输入参数

24
00:01:20,840 --> 00:01:22,770
或者每次递归时

25
00:01:22,770 --> 00:01:26,119
不存在一定的更改条件 你就永远不知道何时停止

26
00:01:27,325 --> 00:01:30,580
你会再次陷入无限递归中

27
00:01:32,585 --> 00:01:34,934
现在我们看一个示例

28
00:01:34,935 --> 00:01:36,805
这是我们的开始代码

29
00:01:36,805 --> 00:01:40,133
在这边 我将写出我们会执行的每行主要代码

30
00:01:40,133 --> 00:01:46,765
我们开始调用输入值为 2 的函数

31
00:01:46,765 --> 00:01:49,615
我们以这个 if 条件开始

32
00:01:49,615 --> 00:01:51,765
因为输入值是 2

33
00:01:51,765 --> 00:01:54,505
并且大于 0 所以我们转到 else 部分

34
00:01:55,550 --> 00:01:59,550
我们先评估这部分内容 然后再向输出变量赋任何值

35
00:02:01,100 --> 00:02:05,260
所以 输入值减 1 也就是 2-1

36
00:02:05,260 --> 00:02:07,550
我们将再次调用该函数

37
00:02:07,550 --> 00:02:10,222
但是输入值为 1 而不是 2

38
00:02:11,980 --> 00:02:13,570
现在到了非常令人困惑的部分

39
00:02:14,720 --> 00:02:17,970
计算机知道你依然没有完成

40
00:02:17,970 --> 00:02:19,240
最初输入值为 2 的调用

41
00:02:19,240 --> 00:02:22,330
你会直接跳到这部分 而不会结束

42
00:02:23,390 --> 00:02:26,290
在该函数的临时内存中 它会记住这点

43
00:02:26,300 --> 00:02:30,300
但是 它实际上是复制了所有这段初始代码

44
00:02:30,300 --> 00:02:33,250
你需要再执行一次 但是输入值变成了 1

45
00:02:34,160 --> 00:02:37,750
这里我缩进了这行内容 表明我们还没有完成初始调用

46
00:02:37,750 --> 00:02:40,770
只是在初始调用内继续调用

47
00:02:42,115 --> 00:02:44,110
我们再执行一次

48
00:02:44,110 --> 00:02:48,600
这次 输入值是 1 依然比 0 大

49
00:02:48,600 --> 00:02:50,230
我们可以跳到 else 部分

50
00:02:51,930 --> 00:02:54,210
同样的情况再发生了一次

51
00:02:54,210 --> 00:02:57,810
在向输出值分配任何内容前 我们需要先完成这段递归语句

52
00:02:59,510 --> 00:03:03,945
这次输入值为 1 所以 1-1 等于 0

53
00:03:03,945 --> 00:03:07,839
我们需要再次调用该递归函数 但是输入值为 0

54
00:03:07,839 --> 00:03:08,965
而不是 1 或 2

55
00:03:10,695 --> 00:03:14,345
我再次表明我们依然没有忘记我们从未解决这段内容

56
00:03:14,345 --> 00:03:18,645
并且没有返回任何值 但是我们需要继续下去

57
00:03:18,645 --> 00:03:19,835
再次执行代码

58
00:03:21,255 --> 00:03:22,995
我们再执行一次吧

59
00:03:22,995 --> 00:03:25,920
这次 情况出现了转机

60
00:03:25,920 --> 00:03:30,720
输入值是 0 所以我们不再需要执行这个 else 部分

61
00:03:30,720 --> 00:03:32,640
我们只是停留在这里

62
00:03:32,640 --> 00:03:37,790
我们返回 0 看见它出现在了这里

63
00:03:38,870 --> 00:03:41,820
现在我们实际上从我们的某个调用中返回了值

64
00:03:41,820 --> 00:03:46,340
我们可以忽略这个输入值为 0 的递归调用

65
00:03:46,340 --> 00:03:49,100
返回到一分钟前关注的输入值为 1 的递归调用

66
00:03:50,320 --> 00:03:53,436
所以我们返回到输入值为 1 的情况

67
00:03:53,436 --> 00:03:57,330
我们评估该语句 得出结果 0 正如我在这边表示的

68
00:03:58,630 --> 00:04:03,280
请记住 我们调用了递归部分 返回了 0

69
00:04:03,280 --> 00:04:07,443
所以可以说这部分内容评估结果是 0

70
00:04:07,443 --> 00:04:10,460
我们可以为输出分配个 0

71
00:04:10,460 --> 00:04:14,582
之前执行的输入值为 1 的调用实际上

72
00:04:14,582 --> 00:04:17,740
返回了一个值 为 0

73
00:04:17,740 --> 00:04:21,225
现在我们可以忽略这段递归调用

74
00:04:21,225 --> 00:04:25,690
返回到输入值为 2 的初始调用

75
00:04:25,690 --> 00:04:29,460
所以返回到了初始调用

76
00:04:29,460 --> 00:04:35,219
它之前是输入为 1 结果为 0 的递归调用

77
00:04:35,220 --> 00:04:38,850
所以可以说输出等于 0

78
00:04:40,230 --> 00:04:44,770
我们再次返回 0 现在初始调用也完成了

79
00:04:46,180 --> 00:04:48,135
太棒了 初始调用返回的是 0

80
00:04:49,260 --> 00:04:52,620
递归非常令人费解 因为你开始用的只是一个方法

81
00:04:52,620 --> 00:04:55,710
但是最终却不知道要调用该方法多少次

82
00:04:57,000 --> 00:05:00,300
当我在思考递归函数的工作原理时

83
00:05:00,300 --> 00:05:04,109
我经常会写一个表格或这样的步骤列表

84
00:05:04,110 --> 00:05:07,970
每次遇到递归调用时 我都会记下相关值

85
00:05:09,620 --> 00:05:13,880
我以前总是把它想象成计算机在漫无边际地运行着

86
00:05:13,880 --> 00:05:17,710
我以这个初始函数开始 然后不断调用其他内容

87
00:05:17,710 --> 00:05:19,570
执行其他操作 执行其他操作

88
00:05:19,570 --> 00:05:20,680
执行其他操作

89
00:05:20,680 --> 00:05:23,950
最终 我会返回到我之前讨论的内容

90
00:05:25,900 --> 00:05:28,799
记住 你的代码会按顺序执行这几行代码

91
00:05:28,800 --> 00:05:31,830
直到你执行了递归部分很多次后

92
00:05:31,830 --> 00:05:34,729
才会为输出分配任何值

93
00:05:36,700 --> 00:05:39,770
在写递归代码时 一定要非常小心

94
00:05:39,770 --> 00:05:41,560
如果基线条件不合理

95
00:05:41,560 --> 00:05:43,490
就可能会陷入无限递归中

96
00:05:44,800 --> 00:05:47,110
假设我们对这个基线条件做个小小的变动

97
00:05:48,480 --> 00:05:51,250
我只是把 &lt;=

98
00:05:51,250 --> 00:05:52,910
替换成了 =

99
00:05:54,200 --> 00:05:58,560
如果输入值为 2 或 1 或 4 甚至 100 万

100
00:05:58,560 --> 00:06:01,500
代码都会正常运行

101
00:06:01,500 --> 00:06:04,680
但是如果输入值小于 0

102
00:06:04,680 --> 00:06:06,190
这段代码就永远不会返回任何值

103
00:06:07,700 --> 00:06:10,890
如果以 -2 开始 你会跳过 if 语句

104
00:06:10,890 --> 00:06:13,650
不断减 1

105
00:06:13,650 --> 00:06:16,640
下次输入值为 -3

106
00:06:16,640 --> 00:06:18,657
然后减 1 得出 -4

107
00:06:18,658 --> 00:06:21,220
减 1 得出 -5 以此类推下去

108
00:06:22,320 --> 00:06:27,840
但是 如果我使用的是小于 然后初始数字为 -2

109
00:06:27,840 --> 00:06:32,454
或 -50 或负 100 万 一旦我满足了基线条件 就会停止

110
00:06:32,454 --> 00:06:35,657
一定要考虑到递归语句可能会具有的

111
00:06:35,657 --> 00:06:36,750
所有不同输入值

112
00:06:38,000 --> 00:06:42,160
最后 如果你真不确定你的递归部分执行的是什么操作

113
00:06:42,160 --> 00:06:45,480
你可以在必要时输出一定的语句

114
00:06:45,480 --> 00:06:47,290
通过输出中位数

115
00:06:47,290 --> 00:06:51,300
你就会知道代码在每步到底执行的是什么操作
