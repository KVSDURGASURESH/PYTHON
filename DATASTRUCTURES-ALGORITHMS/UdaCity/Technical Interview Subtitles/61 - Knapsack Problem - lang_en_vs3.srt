1
00:00:00,290 --> 00:00:04,120
The so-called Knapsack Problem is
another famous thought exercise in

2
00:00:04,120 --> 00:00:04,930
computer science.

3
00:00:06,100 --> 00:00:10,980
Here we have a theoretical knapsack
with a limited weight capacity, and

4
00:00:10,980 --> 00:00:13,860
more items that can possibly fit in it.

5
00:00:13,860 --> 00:00:17,669
Each item has a weight and a value.

6
00:00:17,670 --> 00:00:23,110
The question here is, how can I optimize
the total value of items in my knapsack,

7
00:00:23,110 --> 00:00:24,830
given the weight constraint?

8
00:00:24,830 --> 00:00:29,279
We'll focus on the 0-1 knapsack problem,
where you only have

9
00:00:29,280 --> 00:00:33,370
one of each object and you must
either take or leave a whole object.

10
00:00:34,430 --> 00:00:37,460
In some other variants,
you can take a fraction of an object.

11
00:00:38,740 --> 00:00:42,220
When I heard about this problem,
my first thought was,

12
00:00:42,220 --> 00:00:45,240
just put the objects with
the highest values in first.

13
00:00:46,240 --> 00:00:50,800
but what if putting the two elements
with the highest values hit the weight

14
00:00:50,800 --> 00:00:54,780
limit, but putting all the other
elements in together would actually fit

15
00:00:54,780 --> 00:00:56,920
and have a higher value?

16
00:00:56,920 --> 00:01:00,250
There aren't a lot of actual
knapsacks in computer science, but

17
00:01:00,250 --> 00:01:03,870
this problem describes an optimization
issue that crops up often.

18
00:01:04,910 --> 00:01:09,440
Before devising the best solution,
particularly if you're stuck, it can be

19
00:01:09,440 --> 00:01:13,670
helpful to think of the solution
that's slow but straightforward.

20
00:01:13,670 --> 00:01:16,650
Here we could try every
combination of objects and

21
00:01:16,650 --> 00:01:22,100
just pick the one that's best,
also called the brute force solution.

22
00:01:22,100 --> 00:01:26,670
The runtime of the solution is on
the order of 2 raised to the n,

23
00:01:26,670 --> 00:01:29,530
where n is the number of objects.

24
00:01:29,530 --> 00:01:33,510
There are actually 2 to
the n possible combinations.

25
00:01:33,510 --> 00:01:36,410
There's a precise mathematical
reason for this, but

26
00:01:36,410 --> 00:01:39,899
you could also think of one
combination as a string of length n,

27
00:01:41,110 --> 00:01:46,289
where each spot has a 1 if it's in
the knapsack or a 0 if it's left out.

28
00:01:46,290 --> 00:01:52,200
That means this is an exponential time
algorithm, since the n is an exponent.

29
00:01:52,200 --> 00:01:55,480
We would prefer
a polynomial time algorithm

30
00:01:55,480 --> 00:01:59,320
where the n is multiplied by something
else or has a constant number for

31
00:01:59,320 --> 00:02:03,759
an exponent, which is going to be
much faster for large numbers.
