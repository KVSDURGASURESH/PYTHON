1
00:00:00,530 --> 00:00:05,530
A heap is another specific type of tree
with some of its own additional rules.

2
00:00:05,530 --> 00:00:10,300
In a heap, elements arranged in
increasing or decreasing order

3
00:00:10,300 --> 00:00:15,260
such that the root element is either the
maximum or minimum value in the tree.

4
00:00:15,260 --> 00:00:17,360
There are two different types of heaps.

5
00:00:17,360 --> 00:00:22,700
Max heaps and min heaps that
capture those two situations.

6
00:00:22,700 --> 00:00:27,100
In a max heap, a parent must always
have a greater value than its child so

7
00:00:27,100 --> 00:00:29,570
the root ends up being
the biggest element.

8
00:00:29,570 --> 00:00:34,720
The opposite is true of min heaps, a
parent has a lower value than its child

9
00:00:34,720 --> 00:00:37,600
so the root is the minimum element.

10
00:00:37,600 --> 00:00:42,260
Heaps don't need to be binary trees, so
parents can have any number of children.

11
00:00:42,260 --> 00:00:44,860
Operations like search, insert and

12
00:00:44,860 --> 00:00:48,820
delete can vary a lot based on
the type of heap we're discussing.

13
00:00:48,820 --> 00:00:51,490
Here, I'm going to focus
on a max binary heap.

14
00:00:52,630 --> 00:00:55,500
We're going to keep
the two children rule and

15
00:00:55,500 --> 00:00:57,309
the root will be the maximum element.

16
00:00:57,310 --> 00:01:00,990
In addition,
a binary heap must be a complete tree,

17
00:01:00,990 --> 00:01:04,660
meaning all levels except
the last one are completely full.

18
00:01:04,660 --> 00:01:09,570
If the last level isn't totally full,
values are added from left to right.

19
00:01:09,570 --> 00:01:13,500
The right most leaf will be empty
until the whole row has been filled.

20
00:01:13,500 --> 00:01:16,850
In this heap,
a function that gets the maximum value,

21
00:01:16,850 --> 00:01:20,615
also called peek,
happens in constant time.

22
00:01:20,615 --> 00:01:23,250
Let's see what search looks like.

23
00:01:23,250 --> 00:01:26,750
Should we start our search by
going to the left or the right?

24
00:01:26,750 --> 00:01:31,720
In a BST, we knew which direction to
go at each step by doing comparisons.

25
00:01:31,720 --> 00:01:34,330
Here there's no guarantee either way.

26
00:01:34,330 --> 00:01:38,520
Thus, searching ends up being a linear
time operation since normally,

27
00:01:38,520 --> 00:01:42,590
we can't rely on tricks and
we'll end up searching the entire tree.

28
00:01:42,590 --> 00:01:46,720
One thing to note is that we can
actually use the maxi properties to our

29
00:01:46,720 --> 00:01:48,720
advantage in a search.

30
00:01:48,720 --> 00:01:52,210
For example, we can quit our search
immediately if the element we're

31
00:01:52,210 --> 00:01:54,800
searching for is bigger than the root.

32
00:01:54,800 --> 00:01:55,460
In general,

33
00:01:55,460 --> 00:01:59,199
if our node value is bigger than
the one we're comparing to, we don't

34
00:01:59,200 --> 00:02:03,500
need to check anything in its sub-tree
since we know that it's the biggest.

35
00:02:03,500 --> 00:02:06,160
The worst case remains but
in the average case,

36
00:02:06,160 --> 00:02:09,160
we don't actually need
to search every element.

37
00:02:09,160 --> 00:02:12,490
The average case is
closer to n over two but

38
00:02:12,500 --> 00:02:14,220
that's still approximated
to linear time.
