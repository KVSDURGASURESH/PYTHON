1
00:00:00,330 --> 00:00:04,990
在情形 4 和 5 中 目标节点的父节点是红色 而兄弟节点是黑色

2
00:00:06,340 --> 00:00:09,660
在这两种情形下 你都需要进行旋转

3
00:00:09,660 --> 00:00:14,000
旋转是指移动一组节点 导致树的结构出现变动

4
00:00:14,000 --> 00:00:17,970
但是节点的顺序没有改变

5
00:00:17,970 --> 00:00:20,770
记住 这依然是 BST

6
00:00:20,770 --> 00:00:23,178
我们需要确保元素按照特定的顺序排列

7
00:00:23,178 --> 00:00:26,770
在情形 4 下 我们的红色节点和

8
00:00:26,770 --> 00:00:32,600
其红色父节点不在它们的父节点的同一侧

9
00:00:32,600 --> 00:00:35,410
目标节点是右侧子节点 其父节点是左侧子节点

10
00:00:36,600 --> 00:00:40,650
我们将进行左旋转 节点向左移一个位置

11
00:00:40,650 --> 00:00:43,239
并保持原来的顺序

12
00:00:44,480 --> 00:00:49,349
此时 结构和情形 5 完全一样

13
00:00:49,350 --> 00:00:53,900
红色节点和其红色父节点都位于它们的父节点的同一侧

14
00:00:55,600 --> 00:00:56,400
这是左旋转

15
00:00:57,640 --> 00:01:01,110
现在我们将进行右旋转

16
00:01:01,110 --> 00:01:03,650
这次将同时涉及祖父节点和子节点

17
00:01:04,709 --> 00:01:07,495
我们还需要交换这两个节点的颜色

18
00:01:07,495 --> 00:01:09,178
完成啦！

19
00:01:09,178 --> 00:01:12,660
我们重新排列了节点 并且没有更改任何路径的

20
00:01:12,660 --> 00:01:13,250
黑节点数量

21
00:01:14,260 --> 00:01:18,460
这些就是插入操作会面临的所有情形

22
00:01:18,460 --> 00:01:23,900
Again, we just needed to do some clever
我们只需要巧妙地重新排列 就可以满足红黑树和

23
00:01:23,100 --> 00:01:25,800
BST 特性

24
00:01:25,800 --> 00:01:27,310
在旋转时

25
00:01:27,310 --> 00:01:31,700
我们避免了任何一个子树比其他子树大很多

26
00:01:32,330 --> 00:01:38,364
插入和搜索及删除一样 平均情况和最坏情况下是 O(log(n))

27
00:01:38,364 --> 00:01:44,270
在最坏情况下是 BST O(n) 因为它们可能是非平衡树

28
00:01:44,270 --> 00:01:46,679
因为我们这里要确保保持平衡

29
00:01:46,680 --> 00:01:48,350
所以 运行时间不会太大
