1
00:00:00,950 --> 00:00:04,710
现在我们已经掌握了一些工具 我们可以研究基本算法了

2
00:00:04,710 --> 00:00:08,809
假设你有一个按数字排序的数组

3
00:00:08,810 --> 00:00:12,770
你想知道某个数字是否存在于该数组中

4
00:00:12,770 --> 00:00:16,189
如果从头开始 检查数组中的每个数字

5
00:00:16,190 --> 00:00:19,820
当你的数字非常大时 时间效率就是 O(n)

6
00:00:19,820 --> 00:00:22,270
如果你从另一端开始 也会发生同一情况

7
00:00:22,270 --> 00:00:23,960
如果你的数字非常小

8
00:00:23,960 --> 00:00:27,460
结果可能是最坏情况 时间效率为线性时间

9
00:00:27,460 --> 00:00:30,990
但是 我们可以利用该数组是排序数组的事实

10
00:00:30,990 --> 00:00:33,110
走个巧妙的捷径

11
00:00:33,110 --> 00:00:34,800
我们不从后端开始

12
00:00:34,800 --> 00:00:37,540
而是从中间开始查找

13
00:00:37,540 --> 00:00:41,290
可以看看我的数字是比中间数字大还是小

14
00:00:42,320 --> 00:00:43,970
因为我的数字更大

15
00:00:43,970 --> 00:00:47,640
所以我知道它必须位于数组的后半部分

16
00:00:47,640 --> 00:00:50,880
现在我都不用查找数组的前半部分了

17
00:00:50,880 --> 00:00:54,200
该策略的最迷人之处就是你可以针对数组的

18
00:00:54,200 --> 00:00:57,800
第二部分继续这么猜测

19
00:00:57,800 --> 00:00:59,360
与中间元素对比 然后继续往下查找

20
00:01:00,400 --> 00:01:03,768
我的数字依然比中间的数字大

21
00:01:03,768 --> 00:01:06,185
我现在只需要查看最后一个元素了

22
00:01:06,185 --> 00:01:07,405
最终到达数组结尾处

23
00:01:07,405 --> 00:01:13,160
我们查看了 19 和 29 还是没看到 25

24
00:01:13,160 --> 00:01:16,395
因此可以得出结论 25 不在这个数组中

25
00:01:17,465 --> 00:01:18,155
知道吗？

26
00:01:18,155 --> 00:01:19,915
你已经学会了一个算法

27
00:01:19,915 --> 00:01:23,635
算法就是对解决方案的技巧进行更高级别的

28
00:01:23,635 --> 00:01:25,550
描述

29
00:01:25,550 --> 00:01:27,505
我们刚刚用到的算法就叫做二分查找
