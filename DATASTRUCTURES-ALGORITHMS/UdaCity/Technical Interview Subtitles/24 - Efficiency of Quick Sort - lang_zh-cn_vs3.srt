1
00:00:00,280 --> 00:00:04,630
实际上 快速排序的效率非常复杂

2
00:00:04,630 --> 00:00:07,250
首先 我们来看看最坏情况

3
00:00:07,250 --> 00:00:08,950
效率会是怎样的？

4
00:00:08,950 --> 00:00:11,860
该算法的魅力之处在于

5
00:00:11,860 --> 00:00:13,459
它通过几乎每次都将数组

6
00:00:13,460 --> 00:00:16,410
分成两半减少了对比次数

7
00:00:16,410 --> 00:00:20,710
所以 最坏情况是 我们没法将数组分成两半

8
00:00:20,710 --> 00:00:23,620
每次都要进行所有的对比

9
00:00:23,620 --> 00:00:27,310
如果基准已经处在正确的位置

10
00:00:27,310 --> 00:00:29,990
你将需要进行所有的对比

11
00:00:29,100 --> 00:00:31,800
因为 13 已经是最大的元素

12
00:00:31,800 --> 00:00:35,100
第一次就要将其与所有元素进行对比

13
00:00:35,100 --> 00:00:37,500
结果发现不需要移动它

14
00:00:37,500 --> 00:00:40,540
这一次的对比次数很多

15
00:00:40,540 --> 00:00:44,600
真正的问题在于 下一个值也是最大值

16
00:00:44,600 --> 00:00:47,520
同样 我们需要将其与所有小于它的值对比

17
00:00:47,520 --> 00:00:49,360
没有节省任何步骤

18
00:00:49,360 --> 00:00:52,910
希望这里的对比能够让你想起冒泡排序

19
00:00:52,910 --> 00:00:55,629
记得在冒泡排序中 我们需要将每个元素

20
00:00:55,630 --> 00:00:59,400
与它旁边的元素进行对比 对比一次又一次

21
00:01:00,400 --> 00:01:02,629
最终我们可以不用对比最后的元素

22
00:01:02,630 --> 00:01:04,890
因为我们知道它们已经处在正确的位置

23
00:01:04,890 --> 00:01:09,200
快速排序的最坏情况完全是这样的

24
00:01:09,200 --> 00:01:13,600
也就意味着快速排序的最坏情况是 O(n2)

25
00:01:13,600 --> 00:01:17,539
对于快速排序来说 这种效率实在很糟糕

26
00:01:17,540 --> 00:01:20,600
但是 快速排序的作用主要有两个方面

27
00:01:21,280 --> 00:01:26,660
首先 平均情况和最佳情况的复杂度实际上是 nlog(n)

28
00:01:26,660 --> 00:01:29,570
最佳情况下 基准将移到中间位置

29
00:01:29,570 --> 00:01:32,669
每次我们都需要将数组分成两半

30
00:01:32,670 --> 00:01:36,580
当基准在中间位置时 我们可以查看数组的其他一半部分

31
00:01:36,580 --> 00:01:39,100
将基准也移到中间位置 因为这些基准已经排好序了

32
00:01:39,100 --> 00:01:43,410
所以我们知道所有其他内容也排好了

33
00:01:43,410 --> 00:01:45,700
很快就操作完毕

34
00:01:45,700 --> 00:01:48,340
此时 因为每次都是将数组分成两半

35
00:01:48,340 --> 00:01:50,670
就和归并排序很相似

36
00:01:50,670 --> 00:01:53,970
也就是为何效率是 nlog(n)

37
00:01:53,970 --> 00:01:57,300
平均情况和这个很相似

38
00:01:57,300 --> 00:02:01,550
我们将选择一个随机数 它将移到中间位置 以此类推

39
00:02:01,550 --> 00:02:05,289
但是 如果我们知道在接近排好序时 会上升

40
00:02:05,290 --> 00:02:07,900
我们就不会使用快速排序

41
00:02:07,900 --> 00:02:10,350
因为最终每次都变成最坏情况

42
00:02:10,350 --> 00:02:13,489
第二个作用是可以通过快速排序进行优化

43
00:02:13,490 --> 00:02:15,520
使其运行更快

44
00:02:15,520 --> 00:02:18,330
例如 当你拆分数组时

45
00:02:18,330 --> 00:02:22,630
你可以将程序设置为两部分同时运行

46
00:02:22,630 --> 00:02:25,200
结果会使用相同的计算容量

47
00:02:25,200 --> 00:02:26,950
但是会消耗更少的时间

48
00:02:26,950 --> 00:02:30,490
此外 我们不选择最后一个元素作为基准

49
00:02:30,500 --> 00:02:32,300
而是看看最后几个元素

50
00:02:32,300 --> 00:02:34,350
然后选择中间的元素作为基准

51
00:02:34,350 --> 00:02:37,700
选择中间数可以让你知道整个数组的

52
00:02:37,700 --> 00:02:38,760
中间位置大概是什么

53
00:02:38,760 --> 00:02:42,179
这样 更有机会将元素移到中间

54
00:02:42,180 --> 00:02:44,520
并实现最佳情况

55
00:02:44,520 --> 00:02:47,260
此外 这种版本的快速排序是原地排序

56
00:02:47,260 --> 00:02:49,690
所有没有使用任何额外空间

57
00:02:49,690 --> 00:02:51,530
空间复杂度是常量
