1
00:00:02,400 --> 00:00:05,800
我看看这里是否有任何错误

2
00:00:06,536 --> 00:00:10,212
似乎 dequeue 后面忘记加括号了

3
00:00:10,212 --> 00:00:12,520
现在可以正确调用该方法了

4
00:00:12,520 --> 00:00:13,850
现在写之前提到的

5
00:00:13,850 --> 00:00:15,854
测试条件

6
00:00:15,854 --> 00:00:20,222
我就写在这个小方框里吧

7
00:00:20,222 --> 00:00:23,730
这是 none 矩阵 这是空矩阵

8
00:00:23,730 --> 00:00:27,167
如果是 0 就立即返回 0

9
00:00:27,167 --> 00:00:31,582
能正常运转 如果存在可以运转的测试条件呢？

10
00:00:31,582 --> 00:00:33,858
需要执行这里的大多数代码

11
00:00:33,858 --> 00:00:39,160
[无声音]

12
00:00:39,160 --> 00:00:43,653
继续查看 这个是 0

13
00:00:43,653 --> 00:00:45,891
检查下长度

14
00:00:45,891 --> 00:00:51,216
这个设为 3

15
00:00:51,216 --> 00:00:53,179
这个为 2

16
00:00:53,179 --> 00:00:56,711
查看每个元素

17
00:00:56,711 --> 00:01:00,870
找到第一个元素

18
00:01:00,870 --> 00:01:06,423
增加我的孤独计数器 现在等于 1

19
00:01:06,424 --> 00:01:12,209
这是 FindPartsOfIsland 方法 创建队列

20
00:01:12,209 --> 00:01:17,905
附上这些值 然后这是广度优先搜索

21
00:01:17,905 --> 00:01:23,491
对于这种情形 它的右侧或下方没有元素

22
00:01:23,491 --> 00:01:27,678
所以不需要执行这步 然后转到下一步

23
00:01:27,678 --> 00:01:32,300
返回 0 所以不需要执行任何操作 检查下循环

24
00:01:32,300 --> 00:01:33,387
为 1 所以

25
00:01:33,387 --> 00:01:38,254
我再次增加我的孤独计数器 现在为 2

26
00:01:38,254 --> 00:01:42,794
检查这里 然后找到孤岛的部分

27
00:01:42,794 --> 00:01:45,575
这里实际上有 1

28
00:01:45,575 --> 00:01:50,135
然后添加这些值 添加这些

29
00:01:50,135 --> 00:01:53,293
一起看起来正常 然后是这个 1

30
00:01:53,293 --> 00:01:56,190
这个 1 在那里设为 2

31
00:01:56,190 --> 00:01:57,720
这个设为 2

32
00:01:57,720 --> 00:02:01,340
现在将它俩都添加到队列中 查看它们

33
00:02:01,340 --> 00:02:03,672
我们没有在前端附上任何内容

34
00:02:03,672 --> 00:02:06,490
只是附到队列中

35
00:02:06,490 --> 00:02:09,835
看看这里 没有任何其他内容

36
00:02:09,836 --> 00:02:13,381
基本上是将这些设为 2

37
00:02:13,381 --> 00:02:17,100
然后我可能将访问数组中的所有元素

38
00:02:17,100 --> 00:02:20,970
没有更多的 1 了 所以差不多结束了

39
00:02:20,970 --> 00:02:26,587
看起来这里我忘了返回孤岛数量了

40
00:02:26,587 --> 00:02:33,266
[无声音]

41
00:02:33,266 --> 00:02:34,170
看来可以了

42
00:02:34,170 --> 00:02:37,900
[无声音]

43
00:02:37,910 --> 00:02:39,140
看来他的代码都可行

44
00:02:39,140 --> 00:02:41,858
这家伙不但长得帅 还很聪明

45
00:02:42,980 --> 00:02:45,619
调试过程经常被忽略

46
00:02:45,620 --> 00:02:48,760
但是却是算法面试的重要部分

47
00:02:48,760 --> 00:02:52,480
这一步不仅向面试官展示了他们的代码是可行的

48
00:02:52,480 --> 00:02:55,820
还可以发现编写解决方案时忽略的错误

49
00:02:55,820 --> 00:02:57,310
如果面试者用 Java 等语言编程

50
00:02:58,590 --> 00:03:02,610
很容易丢失英文冒号

51
00:03:02,610 --> 00:03:05,610
或忘记返回结果
