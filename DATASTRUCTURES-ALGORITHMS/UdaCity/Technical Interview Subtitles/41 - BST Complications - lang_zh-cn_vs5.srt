1
00:00:00,800 --> 00:00:04,734
二叉树有一种更具体的类型 叫做二分查找树

2
00:00:04,734 --> 00:00:10,690
二分查找树简称 BST 肯定是二分树

3
00:00:10,690 --> 00:00:14,219
即每个父节点最多有两个子节点

4
00:00:14,220 --> 00:00:20,700
就像数组是一种列表一样 BST 是一种二分树

5
00:00:20,700 --> 00:00:21,490
它具有特定规则 规定了

6
00:00:21,490 --> 00:00:25,430
每个节点的值是如何分配的

7
00:00:25,430 --> 00:00:30,000
BST 是排好序的 所以节点左侧的所有值都比它小

8
00:00:30,100 --> 00:00:34,739
而右侧的所有值都比它大

9
00:00:34,739 --> 00:00:39,714
因为 BST 具有这种结构 所以我们可以快速地执行

10
00:00:39,715 --> 00:00:41,580
搜索、插入和删除等操作

11
00:00:41,580 --> 00:00:43,259
假设我们想找到 7

12
00:00:43,259 --> 00:00:45,340
我们从根部开始

13
00:00:45,340 --> 00:00:49,200
7 比 5 大 所以下一步往右移

14
00:00:49,200 --> 00:00:52,730
因为下一个元素是 8 所以知道下一步是往左移

15
00:00:52,730 --> 00:00:55,290
只需几步就找到我们的元素了

16
00:00:55,290 --> 00:00:58,900
你可能注意到了 我们不需要查找每个元素

17
00:00:58,900 --> 00:01:01,170
就能知道要找的元素在哪

18
00:01:01,170 --> 00:01:04,680
只需看看每个层级的一个值

19
00:01:04,680 --> 00:01:08,130
然后与目标元素对比 就能做出判断

20
00:01:08,130 --> 00:01:12,690
意味着 BST 的搜索运行时间是树的高度

21
00:01:12,690 --> 00:01:16,220
在学习插入时 已经证明是 log(n) 了

22
00:01:16,220 --> 00:01:20,300
插入二分树差不多是相同的流程

23
00:01:20,300 --> 00:01:23,960
从顶部开始 通过对比要插入的元素

24
00:01:23,960 --> 00:01:27,169
快速决定每步要忘哪儿移动

25
00:01:27,170 --> 00:01:29,430
最终找到树上的空缺位置

26
00:01:30,530 --> 00:01:34,100
只要每步都正确地对比元素了

27
00:01:34,100 --> 00:01:38,310
就可以将新元素添加在那儿 而不会违反核心的 BST 特性

28
00:01:39,650 --> 00:01:42,180
删除则比较复杂

29
00:01:43,280 --> 00:01:46,820
但是 和普通二分树的复杂情况是一样的

30
00:01:46,820 --> 00:01:50,710
所以不同情形的解决方案依然适用
